"""
Email Service for sending HTML emails via SMTP.
Uses Python's built-in smtplib and email libraries.
"""
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, Any, Optional
from jinja2 import Template
from pathlib import Path
from config import settings
import logging
from datetime import datetime

logger = logging.getLogger(__name__)


class EmailService:
    """Service for sending formatted HTML emails."""
    
    def __init__(self):
        self.smtp_host = settings.smtp_host
        self.smtp_port = settings.smtp_port
        self.smtp_user = settings.smtp_user
        self.smtp_password = settings.smtp_password
        self.from_email = settings.email_from
        self.from_name = settings.email_from_name
        self.to_email = settings.email_to
        
        # Load email template
        template_path = Path(__file__).parent.parent / "templates" / "email_template.html"
        with open(template_path, 'r') as f:
            self.template = Template(f.read())
    
    def _create_plain_text_fallback(self, article_data: Dict[str, Any]) -> str:
        """
        Create a plain text version of the email for clients that don't support HTML.
        
        Args:
            article_data: Article dictionary
            
        Returns:
            Plain text email body
        """
        topic_title = article_data["topic_title"]
        topic_rationale = article_data["topic_rationale"]
        notion_url = article_data.get("notion_url", settings.notion_parent_url)
        
        text = f"""
{topic_title}
{'=' * len(topic_title)}

{topic_rationale}

Read the full article in Notion: {notion_url}

This article includes:
- Executive overview and first-principles breakdown
- Mental models and frameworks
- Real-world applications for founders, engineers, and relationships
- Practical exercises and a 24-hour experiment
- Curated YouTube videos and research papers

---
Generated by AI Mentor
Sent to Lucky
        """.strip()
        
        return text
    
    def _render_html_email(self, article_data: Dict[str, Any], notion_url: str) -> str:
        """
        Render the HTML email using the template.
        
        Args:
            article_data: Article dictionary from LLM
            notion_url: URL of the created Notion page
            
        Returns:
            Rendered HTML string
        """
        # If article_html is provided by LLM, use it directly
        if "article_html" in article_data and article_data["article_html"].strip().startswith("<!"):
            # LLM provided complete HTML
            return article_data["article_html"]
        
        # Otherwise, use our template
        # Extract experiment data
        experiment = None
        if "exercises" in article_data and "day24" in article_data["exercises"]:
            experiment = article_data["exercises"]["day24"]
        
        # Get hero image
        hero_image_url = None
        if "notion_page" in article_data:
            hero_image_url = article_data["notion_page"].get("cover_image_url")
        
        # Prepare template context
        context = {
            "topic_title": article_data["topic_title"],
            "topic_rationale_short": article_data["topic_rationale"][:200] + "...",
            "tags": article_data.get("tags", []),
            "hero_image_url": hero_image_url,
            "experiment": experiment,
            "article_content_html": article_data.get("article_html", article_data.get("article_markdown", "")),
            "youtube_videos": article_data.get("youtube", [])[:7],
            "papers": article_data.get("papers", [])[:10],
            "notion_url": notion_url,
            "reading_time": article_data.get("reading_time_minutes", 30),
            "word_count": article_data.get("estimated_wordcount", 0),
            "generation_date": datetime.now().strftime("%B %d, %Y"),
            "unsubscribe_url": "#"  # TODO: Implement unsubscribe functionality
        }
        
        return self.template.render(**context)
    
    async def send_article_email(
        self, 
        article_data: Dict[str, Any],
        notion_url: str,
        to_email: Optional[str] = None
    ) -> bool:
        """
        Send the article via email.
        
        Args:
            article_data: Article dictionary from LLM
            notion_url: URL of the Notion page
            to_email: Override recipient email (optional)
            
        Returns:
            True if sent successfully, False otherwise
        """
        to_email = to_email or self.to_email
        subject = article_data.get("email_subject", f"Daily Mentor: {article_data['topic_title']}")
        
        logger.info(f"Preparing to send email: {subject} to {to_email}")
        
        try:
            # Create message
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = f"{self.from_name} <{self.from_email}>"
            msg['To'] = to_email
            msg['Reply-To'] = self.from_email
            
            # Add notion_url to article_data for template
            article_data["notion_url"] = notion_url
            
            # Create plain text and HTML parts
            plain_text = self._create_plain_text_fallback(article_data)
            html_content = self._render_html_email(article_data, notion_url)
            
            part1 = MIMEText(plain_text, 'plain')
            part2 = MIMEText(html_content, 'html')
            
            msg.attach(part1)
            msg.attach(part2)
            
            # Send email
            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
                server.starttls()
                server.login(self.smtp_user, self.smtp_password)
                server.send_message(msg)
            
            logger.info(f"Successfully sent email to {to_email}")
            return True
            
        except smtplib.SMTPAuthenticationError as e:
            logger.error(f"SMTP authentication failed: {e}")
            logger.error("Check your email credentials and app password")
            return False
        except smtplib.SMTPException as e:
            logger.error(f"SMTP error occurred: {e}")
            return False
        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            return False
    
    async def send_test_email(self, to_email: Optional[str] = None) -> bool:
        """
        Send a test email to verify configuration.
        
        Args:
            to_email: Recipient email address
            
        Returns:
            True if sent successfully
        """
        to_email = to_email or self.to_email
        subject = "Dailicle Test Email"
        
        msg = MIMEMultipart('alternative')
        msg['Subject'] = subject
        msg['From'] = f"{self.from_name} <{self.from_email}>"
        msg['To'] = to_email
        
        plain_text = """
This is a test email from Dailicle.

If you received this, your email configuration is working correctly!

The system is ready to send daily article emails.
        """.strip()
        
        html_content = """
<!doctype html>
<html>
<body style="font-family: Arial, sans-serif; padding: 20px;">
    <h2 style="color: #2b6cb0;">âœ… Dailicle Test Email</h2>
    <p>If you received this, your email configuration is working correctly!</p>
    <p>The system is ready to send daily article emails.</p>
</body>
</html>
        """.strip()
        
        part1 = MIMEText(plain_text, 'plain')
        part2 = MIMEText(html_content, 'html')
        
        msg.attach(part1)
        msg.attach(part2)
        
        try:
            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
                server.starttls()
                server.login(self.smtp_user, self.smtp_password)
                server.send_message(msg)
            
            logger.info(f"Test email sent successfully to {to_email}")
            return True
        except Exception as e:
            logger.error(f"Failed to send test email: {e}")
            return False


# Global instance
email_service = EmailService()
